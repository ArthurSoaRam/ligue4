use std::io;

#[derive(Clone, Copy, PartialEq)]
enum Espa√ßoTabuleiro {
    Vazio,
    Jogador1,
    Jogador2,
}

impl Espa√ßoTabuleiro {
    fn to_char(&self) -> char {
        match self {
            Espa√ßoTabuleiro::Vazio => '‚ö´',
            Espa√ßoTabuleiro::Jogador1 => 'üîµ',
            Espa√ßoTabuleiro::Jogador2 => 'üî¥',
        }
    }
}

// indica o estado do jogo
#[derive(PartialEq)]
enum EstadoJogo {
    EmAndamento,
    Vit√≥ria,
    Empate,
}

pub struct Jogo {
    // tabuleiro com 6 linhas e 7 colunas, come√ßando da ponta superior esquerda
    tabuleiro: [[Espa√ßoTabuleiro; 6]; 7],
    vez_de: Espa√ßoTabuleiro,
}

impl Jogo {
    // cria um novo jogo
    pub fn novo() -> Self {
        Self {
            tabuleiro: [[Espa√ßoTabuleiro::Vazio; 6]; 7],
            vez_de: Espa√ßoTabuleiro::Jogador1,
        }
    }
    // imprime o tabuleiro e algumas informa√ß√µes do jogo na tela
    fn print_tabuleiro(&self) {
        println!("===============");
        println!(" 1 2 3 4 5 6 7 ");

        for i in 0..6 {
            for j in 0..7 {
                print!("{}", self.tabuleiro[j][i].to_char());
            }
            println!();
        }
        println!("\nVez de: {}", self.vez_de.to_char());
    }

    // verifica se venceu ap√≥s jogar na posi√ß√£o recebida e retorna EstadoJogo (se est√° em andamento, perdeu ou deu empate)
    fn venceu(&self, l: usize, c: usize) -> EstadoJogo {
        // verificar se deu empate
        for i in 0..7 {
            if self.tabuleiro[i][0] == Espa√ßoTabuleiro::Vazio { break; }
            if i >= 6 { return EstadoJogo::Empate }
        }

        // quantidade de pe√ßas alinhadas da mesma cor
        let mut cont = 1;

        //vertical |
        for i in 1..=3 {
            if l as i32 - (i as i32) < 0 { break; }
            if self.tabuleiro[c][l-i] != self.vez_de { break; }
            cont += 1;
        }
        for i in 1..=3 {
            if l + i >= 6 { break; }
            if self.tabuleiro[c][l+i] != self.vez_de { break; }
            cont += 1;
        }
        
        if cont >= 4 {
            return EstadoJogo::Vit√≥ria;
        }

        //horizontal -
        cont = 1;

        for i in 1..=3 {
            if c as i32 - (i as i32) < 0 { break; }
            if self.tabuleiro[c-i][l] != self.vez_de { break; }
            cont += 1;
        }
        for i in 1..=3 {
            if c + i >= 7 { break; }
            if self.tabuleiro[c+i][l] != self.vez_de { break; }
            cont += 1;
        }

        if cont >= 4 {
            return EstadoJogo::Vit√≥ria;
        }

        // diagonal \
        cont = 1;

        for i in 1..=3 {
            if l as i32 - (i as i32) < 0 || c as i32 - (i as i32) < 0 { break; }
            if self.tabuleiro[c-i][l-i] != self.vez_de { break; }
            cont += 1;
        }
        for i in 1..=3 {
            if l + i >= 6 || c + i >= 7 { break; }
            if self.tabuleiro[c+i][l+i] != self.vez_de { break; }
            cont += 1;
        }

        if cont >= 4 {
            return EstadoJogo::Vit√≥ria;
        }

        // diagonal /
        cont = 1;

        for i in 1..=3 {
            if l as i32 - (i as i32) < 0 ||  c + i >= 7 { break; }
            if self.tabuleiro[c+i][l-i] != self.vez_de { break; }
            cont += 1;
        }
        for i in 1..=3 {
            if l + i >= 6 || c as i32 - (i as i32) < 0 { break; }
            if self.tabuleiro[c-i][l+i] != self.vez_de { break; }
            cont += 1;
        }

        if cont >= 4 {
            return EstadoJogo::Vit√≥ria;
        }

        EstadoJogo::EmAndamento
    }

    // tenta adicionar uma pe√ßa na ao tebuleiro na posi√ß√£o recebida. retorna se conseguiu e se ganhou
    fn adicionar_pe√ßa(&mut self, posi√ß√£o: usize) -> (bool, EstadoJogo) {
        if posi√ß√£o < 7 {
            for i in (0..6).rev() {
                if self.tabuleiro[posi√ß√£o][i] == Espa√ßoTabuleiro::Vazio {
                    // adicionando a pe√ßa ao tabuleiro
                    self.tabuleiro[posi√ß√£o][i] = self.vez_de;

                    let estado = self.venceu(i, posi√ß√£o);

                    return (true, estado);
                }
            }
        }
        (false, EstadoJogo::EmAndamento)
    }

    // recebe input do jogador e retorna a posi√ß√£o que ele escolheu
    fn receber_input() -> usize {
        let mut input_text = String::new();
            
        print!("Digite uma posi√ß√£o para jogar: ");
        io::Write::flush(&mut io::stdout()).expect("flush failed!");
        io::stdin().read_line(&mut input_text).expect("failed to read from stdin");
        let posi√ß√£o: usize = input_text.trim().parse().expect("Invalid input");
        posi√ß√£o -1
    }

    // recebe input do jogador, faz a jogada e troca a vez do jogador. retorna "true" caso um jogador tenha vencido
    fn jogar(&mut self) -> EstadoJogo {
        loop {
            let posi√ß√£o: usize = Jogo::receber_input();

            let resultado = self.adicionar_pe√ßa(posi√ß√£o);
            // se conseguiu adicionar a pe√ßa
            if resultado.0 {
                // se acabou o jogo
                if resultado.1 != EstadoJogo::EmAndamento {
                    return resultado.1;
                }

                // trocando a vez para o outro jogador
                if self.vez_de == Espa√ßoTabuleiro::Jogador1 { self.vez_de = Espa√ßoTabuleiro::Jogador2 }
                else { self.vez_de = Espa√ßoTabuleiro::Jogador1 }

                break;
            }
            println!("Posi√ß√£o inv√°lida!");
        }
        EstadoJogo::EmAndamento
    }

    // come√ßa um novo jogo
    pub fn come√ßar(&mut self) {
        loop {
            self.print_tabuleiro();

            match self.jogar() {
                EstadoJogo::EmAndamento => {},

                EstadoJogo::Vit√≥ria => {
                self.print_tabuleiro();
                println!("Jogador {} venceu!!", self.vez_de.to_char());
                break;
                },

                EstadoJogo::Empate => {
                self.print_tabuleiro();
                println!("Empatou!");
                break;
                },
            }
        }
    }
}